# 并行分布式计算实验报告

## 一、基于 OpenMP 的并行快速排序 (parallel_quicksort.cpp)

### 1. 实现方式

基于 OpenMP 的并行快速排序算法，主要包括：

- 手动实现的快速排序算法，包含串行和并行两个版本
- 使用 OpenMP 的 `sections` 指令对快速排序的左右子数组进行并行处理
- 限制递归深度（最大 4 层），超过阈值后自动切换为串行排序，避免创建过多线程导致的性能下降

### 2. 主要功能模块

- **`quicksort_serial`**：串行快速排序实现
- **`quicksort_parallel`**：并行快速排序实现，包含递归深度控制
- **`generate_random_array`**：生成指定大小的随机整数数组
- **`test_performance`**：性能测试函数，比较串行和并行排序的时间

### 3. 测试配置

- **数据量**：1000、5000、10000、100000 个元素
- **线程数**：1、2、4、8、16 个线程

### 4. 运行方式

- 编译：
  
  ```bash
  g++ -fopenmp parallel_quicksort.cpp -o parallel_quicksort.exe
  ```

- 运行：
  
  ```bash
  ./parallel_quicksort.exe
  ```

### 5. 实验结果

```
并行快速排序算法性能测试
==========================

数据量: 1000
------------------------
测试数据量: 1000，线程数: 1
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------
测试数据量: 1000，线程数: 2
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------
测试数据量: 1000，线程数: 4
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------
测试数据量: 1000，线程数: 8
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------
测试数据量: 1000，线程数: 16
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------

数据量: 5000
------------------------
测试数据量: 5000，线程数: 1
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0.001003 秒
加速比: 0
------------------------
测试数据量: 5000，线程数: 2
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0 秒
加速比: nan
------------------------
测试数据量: 5000，线程数: 4
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0.000999 秒
加速比: 0
------------------------
测试数据量: 5000，线程数: 8
排序结果正确!
串行排序时间: 0.001508 秒
并行排序时间: 0.001006 秒
加速比: 1.49901
------------------------
测试数据量: 5000，线程数: 16
排序结果正确!
串行排序时间: 0 秒
并行排序时间: 0.001005 秒
加速比: 0
------------------------

数据量: 10000
------------------------
测试数据量: 10000，线程数: 1
排序结果正确!
串行排序时间: 0.002168 秒
并行排序时间: 0 秒
加速比: inf
------------------------
测试数据量: 10000，线程数: 2
排序结果正确!
串行排序时间: 0.003512 秒
并行排序时间: 0.001009 秒
加速比: 3.48067
------------------------
测试数据量: 10000，线程数: 4
排序结果正确!
串行排序时间: 0.00051 秒
并行排序时间: 0 秒
加速比: inf
------------------------
测试数据量: 10000，线程数: 8
排序结果正确!
串行排序时间: 0.001005 秒
并行排序时间: 0.000999 秒
加速比: 1.00601
------------------------
测试数据量: 10000，线程数: 16
排序结果正确!
串行排序时间: 0.001005 秒
并行排序时间: 0.001503 秒
加速比: 0.668663
------------------------

数据量: 100000
------------------------
测试数据量: 100000，线程数: 1
排序结果正确!
串行排序时间: 0.014528 秒
并行排序时间: 0.012984 秒
加速比: 1.11892
------------------------
测试数据量: 100000，线程数: 2
排序结果正确!
串行排序时间: 0.014089 秒
并行排序时间: 0.00801 秒
加速比: 1.75893
------------------------
测试数据量: 100000，线程数: 4
排序结果正确!
串行排序时间: 0.013761 秒
并行排序时间: 0.006552 秒
加速比: 2.10027
------------------------
测试数据量: 100000，线程数: 8
排序结果正确!
串行排序时间: 0.01562 秒
并行排序时间: 0.008617 秒
加速比: 1.8127
------------------------
测试数据量: 100000，线程数: 16
排序结果正确!
串行排序时间: 0.013862 秒
并行排序时间: 0.007203 秒
加速比: 1.92448
------------------------
```

在较小数据量时，并行排序时间可能会超过串行排序时间，原因可能是创建、同步和销毁线程需要时间，当数据量很小时，这个开销可能超过并行计算带来的收益。同时可能由于时间过短导致记录为 0 。

## 二、基于 Socket 的 PSRS 并行排序 (psrs_socket.cpp)

### 1. 实现方式

实现了 Parallel Sorting by Regular Sampling (PSRS) 算法，采用 Socket 通信实现分布式并行排序，主要包括：

- 使用 Windows Socket API (Winsock2) 实现服务器-客户端架构
- 包含数据划分、局部排序、正则采样、主元选择、数据重划分和归并排序等完整步骤
- 使用优先队列实现高效的多路归并排序

### 2. 主要功能模块

- **`SocketComm`**：Socket 通信类，封装了服务器创建、客户端连接、数据发送/接收/广播等功能
- **`psrs_server`**：服务器端 PSRS 算法实现，负责数据生成、任务分配和结果合并
- **`psrs_client`**：客户端 PSRS 算法实现，负责局部排序、采样和数据划分
- **`generate_random_array`**：生成指定大小的随机整数数组

### 3. 测试配置

使用`test_psrs.py`脚本实现自动化测试。

- **数据量**：1000、5000、10000、100000、1000000 个元素
- **客户端数量**：1、2、4 个客户端
- **通信模式**：同一台机器上使用本地回环地址 (`127.0.0.1`) 测试

### 4. 运行方式

- 编译：
  
  ```bash
  g++ psrs_socket.cpp -o psrs_socket.exe -lws2_32
  ```

- 运行服务器：
  
  ```bash
  ./psrs_socket.exe server <客户端数量> <数据大小>
  ```

- 运行客户端：
  
  ```bash
  ./psrs_socket.exe client <服务器IP> <客户端ID> <客户端总数>
  ```

  客户端ID 从 `0` 开始，每个递增 `1` ，客户端总数为客户端数量。本机测试时服务器IP 为 `127.0.0.1`。

- 自动化测试：

  ```bash
  python test_psrs.py
  ```

### 5. 实验结果

|数据量|串行时间(秒)|2客户端时间(秒)|2客户端加速比|4客户端时间(秒)|4客户端加速比|
|---|---|---|---|---|---|
|1000|1.0100|1.0167|0.99|1.0299|0.98|
|5000|1.0099|1.0185|0.99|1.0320|0.98|
|10000|1.0135|1.0237|0.99|1.0355|0.98|
|100000|1.0473|1.0660|0.98|1.0641|0.98|
|1000000|1.4304|1.4027|1.02|1.4532|0.98|

加速比小于 1 的原因可能是网络通信开销较大，导致并行计算的效率低于串行计算。